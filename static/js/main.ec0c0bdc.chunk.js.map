{"version":3,"sources":["utils.ts","components/TacticBoard.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Chess","require","getSideToPlayFromFen","fen","turn","makeMove","move","chess","fullMove","validateMove","solution","length","next","san","slice","TacticBoard","tactic","onIncorrect","onCorrect","onSolve","useState","setFen","setSolution","useEffect","setTimeout","blunderMove","transitionDuration","position","width","orientation","onDrop","autoNext","handleMove","from","sourceSquare","to","targetSquare","promotion","fetchTactic","a","axios","post","process","type","res","data","id","fenBefore","forcedLine","App","tactics","setTactics","hint","setHint","loadTactic","newTactic","it","concat","console","log","error","className","sideToPlay","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.ec0c0bdc.chunk.js","sourcesContent":["import { ChessInstance, ShortMove } from \"chess.js\";\n\nconst Chess = require(\"chess.js\");\n\nexport function getSideToPlayFromFen(fen: string) {\n  const chess: ChessInstance = new Chess(fen);\n  return chess.turn();\n}\n\nexport function makeMove(fen: string, move: ShortMove | string) {\n  const chess: ChessInstance = new Chess(fen);\n  const fullMove = chess.move(move);\n  return fullMove ? { fullMove, fen: chess.fen() } : null;\n}\n\nexport function validateMove(\n  fen: string,\n  move: ShortMove | string,\n  solution: string[]\n): null | { solution: string[]; fen: string } {\n  if (solution.length === 0) {\n    return null;\n  }\n\n  const next = makeMove(fen, move);\n\n  if (next && next.fullMove.san === solution[0]) {\n    return {\n      fen: next.fen,\n      solution: solution.slice(1),\n    };\n  }\n\n  return null;\n}\n","import React, { useState, useEffect } from \"react\";\nimport { ShortMove } from \"chess.js\";\nimport Chessboard from \"chessboardjsx\";\nimport Tactic from \"../types/Tactic\";\nimport { getSideToPlayFromFen, makeMove, validateMove } from \"../utils\";\n\ninterface Props {\n  tactic: Tactic;\n  onIncorrect: () => void;\n  onCorrect: () => void;\n  onSolve: () => void;\n}\n\nconst TacticBoard: React.FC<Props> = ({\n  tactic,\n  onIncorrect,\n  onCorrect,\n  onSolve,\n}) => {\n  const [fen, setFen] = useState(tactic.fen);\n  const [solution, setSolution] = useState(tactic.solution);\n\n  useEffect(() => {\n    setTimeout(() => {\n      const next = makeMove(tactic.fen, tactic.blunderMove);\n      if (next) {\n        setFen(next.fen);\n      }\n    }, 100);\n  }, [tactic]);\n\n  const handleMove = (move: string | ShortMove) => {\n    const next = validateMove(fen, move, solution);\n\n    if (next) {\n      setFen(next.fen);\n      setSolution(next.solution);\n\n      if (next.solution.length > 0) {\n        onCorrect();\n\n        const autoNext = validateMove(\n          next.fen,\n          next.solution[0],\n          next.solution\n        );\n\n        if (autoNext) {\n          setFen(autoNext.fen);\n          setSolution(autoNext.solution);\n        }\n      } else {\n        onSolve();\n      }\n    } else {\n      onIncorrect();\n    }\n  };\n\n  return (\n    <Chessboard\n      transitionDuration={200}\n      position={fen}\n      width={400}\n      orientation={getSideToPlayFromFen(tactic.fen) === \"b\" ? \"white\" : \"black\"}\n      onDrop={(move) =>\n        handleMove({\n          from: move.sourceSquare,\n          to: move.targetSquare,\n          promotion: \"q\",\n        })\n      }\n    />\n  );\n};\n\nexport default TacticBoard;\n","import \"./App.css\";\nimport { useEffect, useState } from \"react\";\nimport Tactic from \"./types/Tactic\";\nimport TacticBoard from \"./components/TacticBoard\";\nimport axios from \"axios\";\nimport { getSideToPlayFromFen } from \"./utils\";\n\nfunction App() {\n  const [tactics, setTactics] = useState<Tactic[]>([]);\n  const [hint, setHint] = useState<\n    \"sideToPlay\" | \"incorrect\" | \"correct\" | \"solved\"\n  >(\"sideToPlay\");\n\n  const loadTactic = async () => {\n    try {\n      const newTactic = await fetchTactic();\n      setTactics((it) => it.concat(newTactic));\n      setHint(\"sideToPlay\");\n    } catch (error) {\n      console.log(\"Error loading tactic\", { error });\n    }\n  };\n\n  useEffect(() => {\n    loadTactic();\n    loadTactic();\n  }, []);\n\n  if (tactics.length === 0) {\n    return <div className=\"overlay-loading\">Loading...</div>;\n  }\n\n  const tactic = tactics[0];\n\n  const sideToPlay = getSideToPlayFromFen(tactic.fen);\n\n  return (\n    <div className=\"flex-center\">\n      <h1>Tactics Trainer</h1>\n      <TacticBoard\n        key={tactic.id}\n        tactic={tactic}\n        onCorrect={() => {\n          setHint(\"correct\");\n          setTimeout(() => setHint(\"sideToPlay\"), 1000);\n        }}\n        onIncorrect={() => {\n          setHint(\"incorrect\");\n          setTimeout(() => setHint(\"sideToPlay\"), 1000);\n        }}\n        onSolve={() => {\n          setHint(\"solved\");\n          setTactics((it) => it.slice(1));\n          loadTactic();\n        }}\n      />\n      {hint === \"sideToPlay\" && (\n        <div className=\"tactic-hint\">\n          {sideToPlay === \"b\" ? \"White\" : \"Black\"} to move\n        </div>\n      )}\n\n      {hint === \"correct\" && (\n        <div className=\"tactic-hint tactic-hint-success\">Correct!</div>\n      )}\n\n      {hint === \"incorrect\" && (\n        <div className=\"tactic-hint tactic-hint-error\">Incorrect!</div>\n      )}\n\n      {hint === \"solved\" && (\n        <div className=\"tactic-hint tactic-hint-success\">Solved!</div>\n      )}\n    </div>\n  );\n}\n\nasync function fetchTactic() {\n  const res = await axios.post(\n    `${process.env.REACT_APP_CHESSBLUNDERS_API}/blunder/get`,\n    {\n      type: \"explore\",\n    }\n  );\n\n  const data = res.data.data;\n\n  return {\n    id: data.id,\n    fen: data.fenBefore,\n    blunderMove: data.blunderMove,\n    solution: data.forcedLine,\n  };\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}